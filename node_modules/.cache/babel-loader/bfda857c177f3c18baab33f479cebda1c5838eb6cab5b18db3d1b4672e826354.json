{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// src/composables/useKoziChat.js\nimport { ref, computed, onMounted, onUnmounted, watch } from 'vue';\nconst DEMO_USER_CACHE_KEY = 'kozi-demo-user';\nconst LAST_ACTIVE_SESSION_KEY = 'kozi_last_active_session';\nfunction createFallbackUser(email) {\n  return {\n    users_id: 5791,\n    email,\n    first_name: 'tuyishime',\n    last_name: 'naome',\n    role: 'employee'\n  };\n}\nfunction persistUserToCache(user) {\n  localStorage.setItem(DEMO_USER_CACHE_KEY, JSON.stringify(user));\n  return user;\n}\n\n// Save last active session to localStorage\nfunction saveLastActiveSession(sessionId) {\n  if (!sessionId) return;\n  localStorage.setItem(LAST_ACTIVE_SESSION_KEY, JSON.stringify({\n    sessionId,\n    timestamp: Date.now()\n  }));\n}\n\n// Get last active session from localStorage\nfunction getLastActiveSession() {\n  try {\n    const data = localStorage.getItem(LAST_ACTIVE_SESSION_KEY);\n    return data ? JSON.parse(data) : null;\n  } catch (e) {\n    console.error('Failed to load last active session:', e);\n    return null;\n  }\n}\n\n// Clear last active session\nfunction clearLastActiveSession() {\n  localStorage.removeItem(LAST_ACTIVE_SESSION_KEY);\n}\nexport function useKoziChat() {\n  // Reactive state\n  const currentUser = ref(null);\n  const currentSession = ref(null);\n  const messages = ref([]);\n  const history = ref([]);\n  const chatStarted = ref(false);\n  const loading = ref(false);\n  const error = ref(null);\n  const currentChatTitle = ref('New Chat');\n  const streamingMessage = ref(''); // For real-time streaming\n\n  // ðŸ†• Detect user role (employer = roleId 2, employee = roleId 1)\n  const userRole = ref('employee'); // default\n  const roleId = localStorage.getItem('roleId');\n\n  // More robust role detection\n  if (roleId === '2') {\n    userRole.value = 'employer';\n  } else if (roleId === '1') {\n    userRole.value = 'employee';\n  } else {\n    // If roleId is not set or invalid, try to detect from URL\n    const currentPath = window.location.pathname;\n    if (currentPath.includes('/employer/') || currentPath.includes('/jobprovider/')) {\n      userRole.value = 'employer';\n    } else {\n      userRole.value = 'employee';\n    }\n  }\n\n  // Debug logging\n  console.log('ðŸ” Role Detection Debug:', {\n    roleId: roleId,\n    userRole: userRole.value,\n    currentPath: window.location.pathname,\n    localStorage_roleId: localStorage.getItem('roleId')\n  });\n\n  // Manual override for testing (you can call this in console)\n  window.forceRole = role => {\n    userRole.value = role;\n    console.log('ðŸ”§ Manual role override:', role);\n  };\n\n  // ðŸ†• Get API endpoint prefix based on role\n  const getApiPrefix = () => {\n    const currentPath = window.location.pathname;\n    const isAdmin = isAdminUser();\n    console.log('ðŸ” API Prefix Debug:', {\n      currentPath,\n      userRole: userRole.value,\n      isAdmin,\n      adminRoleId: localStorage.getItem('adminRoleId'),\n      employeeRoleId: localStorage.getItem('employeeRoleId'),\n      employerRoleId: localStorage.getItem('employerRoleId')\n    });\n\n    // Check if user is admin (will now check URL path first)\n    if (isAdmin) {\n      console.log('ðŸ” Admin user detected, using admin API');\n      return '/admin/chat';\n    }\n\n    // Employee uses /chat, Employer uses /chat/employer\n    const prefix = userRole.value === 'employer' ? '/chat/employer' : '/chat';\n    console.log('ðŸ” Using prefix:', prefix, 'for role:', userRole.value);\n    return prefix;\n  };\n\n  // Function to update role based on current URL\n  const updateRoleFromURL = () => {\n    const currentPath = window.location.pathname;\n    const newRole = currentPath.includes('/employer/') || currentPath.includes('/jobprovider/') ? 'employer' : 'employee';\n    if (userRole.value !== newRole) {\n      userRole.value = newRole;\n      console.log('ðŸ”„ Role updated from URL:', {\n        newRole,\n        currentPath\n      });\n    }\n  };\n\n  // Load history from localStorage AND backend on mount\n  onMounted(async () => {\n    // Update role detection on mount\n    updateRoleFromURL();\n    const savedHistory = localStorage.getItem('kozi-chat-history');\n    if (savedHistory) {\n      try {\n        const parsedHistory = JSON.parse(savedHistory);\n        // Ensure all history items have proper timestamps\n        history.value = parsedHistory.map(item => ({\n          ...item,\n          timestamp: item.timestamp || new Date(item.createdAt).getTime() || Date.now(),\n          createdAt: item.createdAt || new Date(item.timestamp) || new Date()\n        }));\n        console.log('Loaded localStorage chat history:', history.value);\n      } catch (e) {\n        console.warn('Failed to load localStorage chat history:', e);\n        history.value = [];\n      }\n    } else {\n      console.log('No saved localStorage chat history found');\n      history.value = [];\n    }\n    await initializeUser();\n    if (currentUser.value) {\n      await loadHistoryFromBackend();\n\n      // ðŸ†• AUTO-RESTORE LAST ACTIVE SESSION\n      const lastActive = getLastActiveSession();\n      console.log('ðŸ” Last active session check:', lastActive);\n      if (lastActive?.sessionId) {\n        // Find this session in history\n        const sessionInHistory = history.value.find(h => h.sessionId === lastActive.sessionId);\n        console.log('ðŸ” Session in history check:', sessionInHistory);\n        console.log('ðŸ” Available history:', history.value);\n        if (sessionInHistory) {\n          console.log('ðŸ”„ Restoring last active session:', sessionInHistory);\n          // Move the loadChatHistory call to after all functions are defined\n          setTimeout(async () => {\n            try {\n              await loadChatHistory(sessionInHistory);\n            } catch (error) {\n              console.error('âŒ Failed to restore session:', error);\n            }\n          }, 100);\n        } else {\n          console.log('âš ï¸ Last active session not found in history, clearing');\n          clearLastActiveSession();\n        }\n      } else {\n        console.log('â„¹ï¸ No last active session found');\n      }\n    }\n  });\n  watch(history, newHistory => {\n    if (newHistory.length > 0) {\n      localStorage.setItem('kozi-chat-history', JSON.stringify(newHistory));\n    }\n  }, {\n    deep: true\n  });\n  const initializeUser = async () => {\n    try {\n      loading.value = true;\n      const user = await getUser();\n      currentUser.value = user;\n      console.log('User initialized:', user);\n    } catch (e) {\n      console.error('Failed to initialize user:', e);\n      error.value = 'Failed to initialize. Please refresh the page.';\n      messages.value = [{\n        sender: 'assistant',\n        text: 'Sorry, I had trouble connecting. Please refresh the page and try again.'\n      }];\n    } finally {\n      loading.value = false;\n    }\n  };\n  const addBotMessage = text => {\n    messages.value.push({\n      sender: 'assistant',\n      text: formatMessage(text)\n    });\n  };\n  const addUserMessage = text => {\n    messages.value.push({\n      sender: 'user',\n      text\n    });\n  };\n  const generateChatTitle = firstMessage => {\n    if (!firstMessage) return 'New Chat';\n    let title = firstMessage.trim();\n    title = title.replace(/^(how|what|when|where|why|can|could|would|should|tell me|help me)\\s+/i, '');\n    title = title.charAt(0).toUpperCase() + title.slice(1);\n    if (title.length > 50) {\n      title = title.substring(0, 47) + '...';\n    }\n    return title || 'New Chat';\n  };\n  const saveCurrentChatToHistory = () => {\n    if (!currentSession.value || messages.value.length === 0) return;\n    const firstUserMessage = messages.value.find(m => m.sender === 'user')?.text;\n    const finalTitle = firstUserMessage ? generateChatTitle(firstUserMessage) : currentChatTitle.value;\n    const lastMessage = messages.value[messages.value.length - 1];\n    let cleanLastMessage = '';\n    if (lastMessage) {\n      if (lastMessage.sender === 'user') {\n        cleanLastMessage = lastMessage.text;\n      } else {\n        cleanLastMessage = stripHtmlAndFormat(lastMessage.text);\n      }\n    }\n\n    // FIX: Use current timestamp for new entries\n    const currentTimestamp = Date.now();\n    const chatEntry = {\n      sessionId: currentSession.value,\n      title: finalTitle,\n      date: new Date().toLocaleDateString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      }),\n      timestamp: currentTimestamp,\n      // Use current timestamp\n      messageCount: messages.value.length,\n      lastMessage: cleanLastMessage.substring(0, 100),\n      createdAt: new Date(currentTimestamp) // Add createdAt field\n    };\n\n    // Remove existing entry and add new one at the beginning\n    const filtered = history.value.filter(item => item.sessionId !== currentSession.value);\n    history.value = [chatEntry, ...filtered].slice(0, 50);\n    console.log('Saved chat to history:', chatEntry);\n  };\n  const startNewChat = async () => {\n    if (!currentUser.value) {\n      console.warn('No user available for new chat â€” initializing a demo user');\n      try {\n        await initializeUser();\n      } catch (e) {\n        // fallthrough, initializeUser handles its own errors\n      }\n      if (!currentUser.value) return;\n    }\n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory();\n    }\n    messages.value = [];\n    currentSession.value = null;\n    chatStarted.value = false;\n    error.value = null;\n    currentChatTitle.value = 'New Chat';\n    clearLastActiveSession(); // ðŸ†• Clear tracking for new chat\n    loading.value = true;\n    try {\n      const data = await startSession(currentUser.value.users_id, null, getApiPrefix());\n      console.log('Session started:', data);\n      if (data?.data?.session_id) {\n        currentSession.value = data.data.session_id;\n        chatStarted.value = true;\n        saveLastActiveSession(data.data.session_id); // ðŸ†• Track this session\n      } else {\n        throw new Error('Invalid session response');\n      }\n    } catch (e) {\n      console.error('Failed to start session:', e);\n      error.value = 'Failed to start chat session';\n      addBotMessage('Sorry, I had trouble starting our chat. Please try again.');\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  // ðŸš€ UPDATED: Streaming message handler\n  const sendMessage = async text => {\n    if (!text.trim() || !currentUser.value || loading.value) {\n      return;\n    }\n    console.log('Sending message:', text);\n\n    // Auto-start chat if needed\n    if (!chatStarted.value || !currentSession.value) {\n      console.log('Auto-starting chat session...');\n      try {\n        loading.value = true;\n        const data = await startSession(currentUser.value.users_id, null, getApiPrefix());\n        if (data?.data?.session_id) {\n          currentSession.value = data.data.session_id;\n          chatStarted.value = true;\n          saveLastActiveSession(data.data.session_id); // ðŸ†• Track this session\n        } else {\n          throw new Error('Failed to start session');\n        }\n      } catch (e) {\n        console.error('Auto-start failed:', e);\n        addBotMessage('Sorry, I could not connect right now. Please try again in a moment.');\n        loading.value = false;\n        return;\n      } finally {\n        loading.value = false;\n      }\n    }\n\n    // Add user message immediately\n    addUserMessage(text);\n    const userMessages = messages.value.filter(m => m.sender === 'user');\n    const isFirstUserMessage = userMessages.length === 1;\n    if (isFirstUserMessage) {\n      const newTitle = generateChatTitle(text);\n      currentChatTitle.value = newTitle;\n    }\n\n    // Create empty placeholder for streaming response (shows only bot icon + typing dots)\n    const botMessageIndex = messages.value.length;\n    messages.value.push({\n      sender: 'assistant',\n      text: '',\n      // Start with empty content\n      streaming: true\n    });\n    loading.value = true;\n    error.value = null;\n    streamingMessage.value = '';\n    try {\n      // ðŸš€ Call streaming API\n      await streamChatMessage(currentSession.value, text, isFirstUserMessage, chunk => {\n        // Only process content chunks, ignore status\n        if (chunk) {\n          streamingMessage.value += chunk;\n          messages.value[botMessageIndex].text = formatMessage(streamingMessage.value);\n          messages.value[botMessageIndex].streaming = true;\n        }\n      }, jobs => {\n        // Handle job data if provided\n        if (jobs && Array.isArray(jobs)) {\n          messages.value[botMessageIndex].jobs = jobs;\n        }\n      }, candidates => {\n        // Handle candidate data if provided\n        if (candidates && Array.isArray(candidates)) {\n          messages.value[botMessageIndex].candidates = candidates;\n        }\n      }, title => {\n        // Title update callback\n        if (title) {\n          currentChatTitle.value = title;\n\n          // Update the current session title in history\n          const sessionIndex = history.value.findIndex(h => h.sessionId === currentSession.value);\n          if (sessionIndex !== -1) {\n            history.value[sessionIndex].title = title;\n            // Update localStorage\n            localStorage.setItem('kozi_chat_history', JSON.stringify(history.value));\n          }\n        }\n      }, getApiPrefix());\n\n      // Mark streaming as complete\n      messages.value[botMessageIndex].streaming = false;\n    } catch (e) {\n      console.error('Failed to send message:', e);\n      error.value = 'Failed to send message';\n      // Replace the empty streaming bubble with a friendly error card\n      messages.value[botMessageIndex] = {\n        sender: 'assistant',\n        text: formatMessage('**We hit a hiccup.**\\n\\n- Please check your internet and try again.\\n- If this keeps happening, refresh the page.'),\n        streaming: false\n      };\n    } finally {\n      loading.value = false;\n      streamingMessage.value = '';\n    }\n  };\n  const sendSuggestion = async text => {\n    await sendMessage(text);\n  };\n  const loadChatHistory = async historyItem => {\n    if (!historyItem.sessionId) return;\n    console.log('Loading chat history for session:', historyItem.sessionId);\n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory();\n    }\n    loading.value = true;\n    try {\n      const data = await getChatHistory(historyItem.sessionId, getApiPrefix());\n      console.log('Full response from getChatHistory:', data);\n      let loadedMessages = [];\n      if (data?.data?.messages && Array.isArray(data.data.messages)) {\n        loadedMessages = data.data.messages;\n      } else if (data?.messages && Array.isArray(data.messages)) {\n        loadedMessages = data.messages;\n      } else if (Array.isArray(data)) {\n        loadedMessages = data;\n      }\n      if (loadedMessages.length > 0) {\n        const msgs = loadedMessages.map(m => ({\n          sender: m.type === 'user' ? 'user' : 'assistant',\n          text: m.type === 'user' ? m.content : formatMessage(m.content || m.message || '')\n        }));\n        console.log('Processed messages:', msgs);\n        messages.value = msgs;\n        currentSession.value = historyItem.sessionId;\n        currentChatTitle.value = historyItem.title;\n        chatStarted.value = true;\n        saveLastActiveSession(historyItem.sessionId); // ðŸ†• Track this session\n      } else {\n        currentSession.value = historyItem.sessionId;\n        currentChatTitle.value = historyItem.title;\n        chatStarted.value = true;\n        saveLastActiveSession(historyItem.sessionId); // ðŸ†• Track this session\n        messages.value = [];\n      }\n    } catch (e) {\n      console.error('Failed to load history:', e);\n      currentSession.value = historyItem.sessionId;\n      currentChatTitle.value = historyItem.title;\n      chatStarted.value = true;\n      saveLastActiveSession(historyItem.sessionId); // ðŸ†• Track this session\n      messages.value = [];\n    } finally {\n      loading.value = false;\n    }\n  };\n  async function getUserChatSessions(users_id) {\n    const url = `${API_BASE}${getApiPrefix()}/sessions?users_id=${users_id}`;\n    const res = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!res.ok) {\n      const errorText = await res.text();\n      console.error('getUserChatSessions error:', res.status, errorText);\n      throw new Error(`getUserChatSessions failed: ${res.status}`);\n    }\n    return await res.json();\n  }\n  const loadHistoryFromBackend = async () => {\n    if (!currentUser.value) return;\n    try {\n      console.log('Loading chat history from backend for user:', currentUser.value.users_id);\n      const data = await getUserChatSessions(currentUser.value.users_id);\n      if (data?.sessions && Array.isArray(data.sessions)) {\n        const backendHistory = data.sessions.map(session => {\n          const lastMessage = session.messages && session.messages.length > 0 ? session.messages[session.messages.length - 1] : null;\n          let cleanLastMessage = '';\n          if (lastMessage) {\n            cleanLastMessage = lastMessage.type === 'user' ? lastMessage.content : stripHtmlAndFormat(lastMessage.content);\n          }\n\n          // FIX: Use proper timestamp from backend\n          const sessionTimestamp = session.timestamp || new Date(session.created_at).getTime() || new Date(session.createdAt).getTime() || Date.now();\n          return {\n            sessionId: session.id,\n            title: session.title || 'New Chat',\n            date: new Date(sessionTimestamp).toLocaleDateString('en-US', {\n              month: 'short',\n              day: 'numeric',\n              hour: '2-digit',\n              minute: '2-digit'\n            }),\n            timestamp: sessionTimestamp,\n            // Use the proper timestamp\n            messageCount: session.messages ? session.messages.length : 0,\n            lastMessage: cleanLastMessage.substring(0, 100),\n            // Add createdAt for consistency\n            createdAt: new Date(sessionTimestamp)\n          };\n        });\n\n        // Sort backend history by timestamp descending (newest first)\n        backendHistory.sort((a, b) => b.timestamp - a.timestamp);\n        history.value = backendHistory;\n        console.log('Loaded backend chat history:', backendHistory);\n        localStorage.setItem('kozi-chat-history', JSON.stringify(backendHistory));\n      } else {\n        console.log('No chat sessions found in backend');\n      }\n    } catch (e) {\n      console.error('Failed to load chat history from backend:', e);\n    }\n  };\n\n  // Delete a chat session by ID (backend + local)\n  const deleteHistoryItem = async sessionId => {\n    if (!sessionId) return;\n    try {\n      const url = `${API_BASE}${getApiPrefix()}/session/${sessionId}`;\n      const res = await fetch(url, {\n        method: \"DELETE\"\n      });\n      if (!res.ok) {\n        const errorText = await res.text();\n        console.error(\"deleteChatSession error:\", res.status, errorText);\n        throw new Error(`deleteChatSession failed: ${res.status}`);\n      }\n      const result = await res.json();\n      console.log(\"Deleted chat session:\", result);\n\n      // âœ… Remove from local history (filter instead of recursion)\n      history.value = history.value.filter(item => item.sessionId !== sessionId);\n\n      // Reset current session if it was the one deleted\n      if (currentSession.value === sessionId) {\n        currentSession.value = null;\n        messages.value = [];\n        currentChatTitle.value = \"New Chat\";\n        chatStarted.value = false;\n        clearLastActiveSession(); // ðŸ†• Clear tracking\n      }\n      return result;\n    } catch (err) {\n      console.error(\"Failed to delete chat session:\", err);\n      throw err;\n    }\n  };\n  const clearAllHistory = async () => {\n    // âœ… Get users_id from currentUser\n    if (!currentUser.value || !currentUser.value.users_id) {\n      console.error(\"âŒ Cannot clear history: User not logged in\");\n      return;\n    }\n    const users_id = currentUser.value.users_id;\n    try {\n      // Clear local history\n      history.value = [];\n      localStorage.removeItem(\"kozi-chat-history\");\n\n      // Call backend API to clear sessions\n      const res = await fetch(`${API_BASE}${getApiPrefix()}/sessions/all`, {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          users_id\n        })\n      });\n      if (!res.ok) {\n        const data = await res.json();\n        console.error(\"âŒ Failed to clear server history:\", data.error || data);\n        return;\n      }\n      const data = await res.json();\n      console.log(`âœ… Cleared ${data.deletedCount} sessions from server`);\n\n      // âœ… Reset current session state\n      currentSession.value = null;\n      messages.value = [];\n      currentChatTitle.value = \"New Chat\";\n      chatStarted.value = false;\n      clearLastActiveSession(); // ðŸ†• Clear tracking\n    } catch (err) {\n      console.error(\"âŒ Error clearing history:\", err);\n    }\n  };\n  const toggleTheme = () => {\n    document.body.classList.toggle('dark');\n  };\n  const handleBeforeUnload = () => {\n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory();\n    }\n  };\n\n  // Debug function to check timestamp consistency\n  const debugHistoryTimestamps = () => {\n    console.log('=== HISTORY TIMESTAMP DEBUG ===');\n    history.value.forEach((item, index) => {\n      console.log(`[${index}] ${item.title}:`, {\n        timestamp: item.timestamp,\n        date: item.date,\n        createdAt: item.createdAt,\n        sessionId: item.sessionId\n      });\n    });\n  };\n  onMounted(() => {\n    window.addEventListener('beforeunload', handleBeforeUnload);\n  });\n  onUnmounted(() => {\n    window.removeEventListener('beforeunload', handleBeforeUnload);\n    handleBeforeUnload();\n  });\n  return {\n    // State\n    currentUser: computed(() => currentUser.value),\n    currentSession: computed(() => currentSession.value),\n    messages: computed(() => messages.value),\n    history: computed(() => history.value),\n    chatStarted: computed(() => chatStarted.value),\n    loading: computed(() => loading.value),\n    error: computed(() => error.value),\n    currentChatTitle: computed(() => currentChatTitle.value),\n    // Actions\n    startNewChat,\n    sendMessage,\n    sendSuggestion,\n    loadChatHistory,\n    deleteHistoryItem,\n    clearAllHistory,\n    toggleTheme,\n    debugHistoryTimestamps // Export debug function\n  };\n}\n\n// Utility functions\nfunction stripHtmlAndFormat(text = '') {\n  if (!text) return '';\n  let cleaned = text.replace(/<[^>]*>/g, '');\n  cleaned = cleaned.replace(/\\*\\*(.+?)\\*\\*/g, '$1');\n  cleaned = cleaned.replace(/\\*(.+?)\\*/g, '$1');\n  cleaned = cleaned.replace(/#{1,6}\\s*(.+)/g, '$1');\n  cleaned = cleaned.replace(/^\\d+\\.\\s*/gm, '');\n  cleaned = cleaned.replace(/^[-â€¢]\\s*/gm, '');\n  cleaned = cleaned.replace(/\\s+/g, ' ').trim();\n  return cleaned;\n}\nfunction formatMessage(message = '') {\n  if (!message) return '';\n  let formatted = String(message).trim();\n\n  // Remove any orphan/mismatched **\n  formatted = formatted.replace(/(^|\\s)\\*\\*([^*]+)(\\s|$)/g, '$1<strong>$2</strong>$3');\n  formatted = formatted.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');\n  formatted = formatted.replace(/\\*([^*]+)\\*/g, '<em>$1</em>');\n\n  // Strip markdown headings / blockquotes\n  formatted = formatted.replace(/^[#>]+\\s*/gm, '');\n\n  // Numbered list items â†’ custom styled divs\n  formatted = formatted.replace(/^(\\d+)\\.\\s+([^:]+:\\s*.+)$/gm, '<div class=\"numbered-item large-font\"><span class=\"number\">$1.</span><span class=\"full-text\"> $2</span></div>');\n\n  // Bullet list items\n  formatted = formatted.replace(/^\\s*[-â€¢]\\s+(.+)$/gm, '<div class=\"bullet-item large-font\">$1</div>');\n\n  // Section headers\n  formatted = formatted.replace(/^(.+):$/gm, '<div class=\"section-header large-font\">$1</div>');\n\n  // Paragraph spacing\n  formatted = formatted.replace(/([^\\n])\\n\\n([^\\n])/g, '$1</p><p class=\"large-font\">$2');\n  formatted = formatted.replace(/(?<!<\\/div>)\\n(?!<div)/g, '<br>');\n  formatted = formatted.replace(/^\\s*<br>\\s*<br>\\s*/, '');\n\n  // Wrap in <p> if not already formatted\n  if (!formatted.includes('<div') && !formatted.includes('<p>')) {\n    formatted = `<p class=\"large-font\">${formatted}</p>`;\n  }\n  return formatted;\n}\n\n// ===== API integration with STREAMING =====\nconst API_BASE = (import.meta?.env?.VITE_API_URL || process.env.VUE_APP_API_URL || 'http://localhost:5050/api').replace(/\\/+$/, '');\n\n// Admin detection logic\nfunction isAdminUser() {\n  // Check current URL path first - only detect admin when actually on admin dashboard\n  const currentPath = window.location.pathname;\n  const isOnAdminDashboard = currentPath.startsWith('/admin');\n  if (!isOnAdminDashboard) {\n    return false; // If not on admin dashboard, definitely not admin\n  }\n\n  // If on admin dashboard, verify admin credentials\n  const adminRoleId = localStorage.getItem('adminRoleId');\n  const userEmail = localStorage.getItem('userEmail') || '';\n  return adminRoleId === '3' || userEmail === 'admin@kozi.rw' || userEmail.includes('admin');\n}\n\n// Generic fetch with timeout (prevents infinite spinner if backend is down)\nasync function fetchWithTimeout(resource, options = {}) {\n  const {\n    timeout = 10000\n  } = options; // 10s default\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n  try {\n    const response = await fetch(resource, {\n      ...options,\n      signal: controller.signal\n    });\n    return response;\n  } finally {\n    clearTimeout(id);\n  }\n}\nasync function getUser(email = process.env.VUE_APP_EMPLOYEE_EMAIL || 'test@example.com') {\n  try {\n    const API_TOKEN = process.env.VUE_APP_KOZI_API_TOKEN || 'your_kozi_api_token_here';\n\n    // Check local cache first\n    const cached = localStorage.getItem(DEMO_USER_CACHE_KEY);\n    if (cached) {\n      try {\n        const user = JSON.parse(cached);\n        if (user && user.users_id && user.email === email) {\n          return user;\n        } else {\n          localStorage.removeItem(DEMO_USER_CACHE_KEY);\n        }\n      } catch (e) {\n        localStorage.removeItem(DEMO_USER_CACHE_KEY);\n      }\n    }\n    if (!API_TOKEN) {\n      console.warn('Missing VITE_KOZI_API_TOKEN. Using demo user profile instead.');\n      return persistUserToCache(createFallbackUser(email));\n    }\n\n    // Fetch user_id\n    const resId = await fetch(`https://apis.kozi.rw/get_user_id_by_email/${encodeURIComponent(email)}`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${API_TOKEN}`\n      }\n    });\n    if (!resId.ok) throw new Error(\"Failed to fetch user ID\");\n    const dataId = await resId.json();\n\n    // Fetch full profile to get real name\n    const resProfile = await fetch(`https://apis.kozi.rw/provider/view_profile/${dataId.users_id}`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${API_TOKEN}`\n      }\n    });\n    if (!resProfile.ok) throw new Error(\"Failed to fetch user profile\");\n    const profile = await resProfile.json();\n\n    // Build user object\n    const user = {\n      users_id: dataId.users_id,\n      email,\n      first_name: profile.first_name || \"Alice\",\n      last_name: profile.last_name || \"Admin\",\n      role: \"employee\"\n    };\n    return persistUserToCache(user);\n  } catch (e) {\n    console.error(\"getUser error:\", e);\n    return persistUserToCache(createFallbackUser(email));\n  }\n}\nasync function startSession(users_id, firstMessage, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}/new`;\n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      users_id,\n      firstMessage\n    }),\n    timeout: 10000\n  });\n  if (!res.ok) {\n    const errorText = await res.text().catch(() => '');\n    console.error('startSession error:', res.status, errorText);\n    throw new Error(`Start session failed (${res.status}). ${errorText || ''}`);\n  }\n  return await res.json();\n}\n\n// ðŸš€ NEW: Streaming message function\nasync function streamChatMessage(sessionId, message, isFirstUserMessage, onChunk, onJobs, onCandidates, onTitle, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}`;\n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      sessionId,\n      message,\n      isFirstUserMessage\n    }),\n    timeout: 60000 // Increased timeout for job searches\n  });\n  if (!res.ok) {\n    const errorText = await res.text().catch(() => '');\n    console.error('streamChatMessage error:', res.status, errorText);\n    throw new Error(`Chat failed (${res.status}). ${errorText || ''}`);\n  }\n\n  // If backend responded with JSON (non-SSE fallback), handle gracefully\n  const contentType = res.headers.get('content-type') || '';\n  if (contentType.includes('application/json')) {\n    const json = await res.json();\n    if (json?.data?.content) {\n      onChunk(json.data.content, null);\n    } else if (json?.content) {\n      onChunk(json.content, null);\n    } else if (json?.messages) {\n      // Join messages content for display\n      const joined = (json.messages || []).map(m => m.type === 'user' ? '' : m.content).filter(Boolean).join('\\n');\n      if (joined) onChunk(joined, null);\n    }\n    return;\n  }\n\n  // Handle SSE streaming\n  if (!res.body || !res.body.getReader) {\n    // Some environments (older browsers/proxies) may buffer the whole body\n    const text = await res.text();\n    if (text) {\n      try {\n        const maybe = JSON.parse(text);\n        if (maybe?.content) onChunk(maybe.content, null);\n      } catch {\n        onChunk(text, null);\n      }\n    }\n    return;\n  }\n  const reader = res.body.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, {\n      stream: true\n    });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() || '';\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed.startsWith('data:')) continue;\n      const payload = trimmed.slice(5).trim();\n      if (!payload || payload === '[DONE]') continue;\n      try {\n        const event = JSON.parse(payload);\n        if (event.content) {\n          // Content chunk - only process actual content\n          onChunk(event.content, null);\n        } else if (event.jobs) {\n          // Job data\n          onJobs(event.jobs);\n        } else if (event.candidates) {\n          // Candidate data\n          onCandidates(event.candidates);\n        } else if (event.title) {\n          // Title update\n          onTitle(event.title);\n        } else if (event.done) {\n          // Streaming complete\n          break;\n        } else if (event.error) {\n          throw new Error(event.error);\n        }\n        // Ignore status events (processing, generating)\n      } catch (parseError) {\n        console.warn('Failed to parse SSE event:', parseError);\n      }\n    }\n  }\n}\nasync function getChatHistory(sessionId, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}?action=loadPreviousSession`;\n  console.log('Fetching chat history from:', url, 'with sessionId:', sessionId);\n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      sessionId\n    }),\n    timeout: 10000\n  });\n  if (!res.ok) {\n    const errorText = await res.text();\n    console.error('getChatHistory error:', res.status, errorText);\n    throw new Error(`getChatHistory failed: ${res.status}`);\n  }\n  const responseData = await res.json();\n  console.log('Raw response from getChatHistory:', JSON.stringify(responseData, null, 2));\n  return responseData;\n}","map":{"version":3,"names":["ref","computed","onMounted","onUnmounted","watch","DEMO_USER_CACHE_KEY","LAST_ACTIVE_SESSION_KEY","createFallbackUser","email","users_id","first_name","last_name","role","persistUserToCache","user","localStorage","setItem","JSON","stringify","saveLastActiveSession","sessionId","timestamp","Date","now","getLastActiveSession","data","getItem","parse","e","console","error","clearLastActiveSession","removeItem","useKoziChat","currentUser","currentSession","messages","history","chatStarted","loading","currentChatTitle","streamingMessage","userRole","roleId","value","currentPath","window","location","pathname","includes","log","localStorage_roleId","forceRole","getApiPrefix","isAdmin","isAdminUser","adminRoleId","employeeRoleId","employerRoleId","prefix","updateRoleFromURL","newRole","savedHistory","parsedHistory","map","item","createdAt","getTime","warn","initializeUser","loadHistoryFromBackend","lastActive","sessionInHistory","find","h","setTimeout","loadChatHistory","newHistory","length","deep","getUser","sender","text","addBotMessage","push","formatMessage","addUserMessage","generateChatTitle","firstMessage","title","trim","replace","charAt","toUpperCase","slice","substring","saveCurrentChatToHistory","firstUserMessage","m","finalTitle","lastMessage","cleanLastMessage","stripHtmlAndFormat","currentTimestamp","chatEntry","date","toLocaleDateString","month","day","hour","minute","messageCount","filtered","filter","startNewChat","startSession","session_id","Error","sendMessage","userMessages","isFirstUserMessage","newTitle","botMessageIndex","streaming","streamChatMessage","chunk","jobs","Array","isArray","candidates","sessionIndex","findIndex","sendSuggestion","historyItem","getChatHistory","loadedMessages","msgs","type","content","message","getUserChatSessions","url","API_BASE","res","fetch","method","headers","ok","errorText","status","json","sessions","backendHistory","session","sessionTimestamp","created_at","id","sort","a","b","deleteHistoryItem","result","err","clearAllHistory","body","deletedCount","toggleTheme","document","classList","toggle","handleBeforeUnload","debugHistoryTimestamps","forEach","index","addEventListener","removeEventListener","cleaned","formatted","String","import","meta","env","VITE_API_URL","process","VUE_APP_API_URL","isOnAdminDashboard","startsWith","userEmail","fetchWithTimeout","resource","options","timeout","controller","AbortController","abort","response","signal","clearTimeout","VUE_APP_EMPLOYEE_EMAIL","API_TOKEN","VUE_APP_KOZI_API_TOKEN","cached","resId","encodeURIComponent","Authorization","dataId","resProfile","profile","rolePrefix","catch","onChunk","onJobs","onCandidates","onTitle","contentType","get","joined","Boolean","join","getReader","maybe","reader","decoder","TextDecoder","buffer","done","read","decode","stream","lines","split","pop","line","trimmed","payload","event","parseError","responseData"],"sources":["/Users/gentil/Desktop/Kozi-ai-agent/src/composables/useKoziChat.js"],"sourcesContent":["// src/composables/useKoziChat.js\nimport { ref, computed, onMounted, onUnmounted, watch } from 'vue'\n\nconst DEMO_USER_CACHE_KEY = 'kozi-demo-user'\nconst LAST_ACTIVE_SESSION_KEY = 'kozi_last_active_session'\n\nfunction createFallbackUser(email) {\n  return {\n    users_id: 5791,\n    email,\n    first_name: 'tuyishime',\n    last_name: 'naome',\n    role: 'employee'\n  }\n}\n\nfunction persistUserToCache(user) {\n  localStorage.setItem(DEMO_USER_CACHE_KEY, JSON.stringify(user))\n  return user\n}\n\n// Save last active session to localStorage\nfunction saveLastActiveSession(sessionId) {\n  if (!sessionId) return\n  localStorage.setItem(LAST_ACTIVE_SESSION_KEY, JSON.stringify({\n    sessionId,\n    timestamp: Date.now()\n  }))\n}\n\n// Get last active session from localStorage\nfunction getLastActiveSession() {\n  try {\n    const data = localStorage.getItem(LAST_ACTIVE_SESSION_KEY)\n    return data ? JSON.parse(data) : null\n  } catch (e) {\n    console.error('Failed to load last active session:', e)\n    return null\n  }\n}\n\n// Clear last active session\nfunction clearLastActiveSession() {\n  localStorage.removeItem(LAST_ACTIVE_SESSION_KEY)\n}\n\nexport function useKoziChat() {\n  // Reactive state\n  const currentUser = ref(null)\n  const currentSession = ref(null)\n  const messages = ref([])\n  const history = ref([])\n  const chatStarted = ref(false)\n  const loading = ref(false)\n  const error = ref(null)\n  const currentChatTitle = ref('New Chat')\n  const streamingMessage = ref('') // For real-time streaming\n  \n  // ðŸ†• Detect user role (employer = roleId 2, employee = roleId 1)\n  const userRole = ref('employee') // default\n  const roleId = localStorage.getItem('roleId')\n  \n  // More robust role detection\n  if (roleId === '2') {\n    userRole.value = 'employer'\n  } else if (roleId === '1') {\n    userRole.value = 'employee'\n  } else {\n    // If roleId is not set or invalid, try to detect from URL\n    const currentPath = window.location.pathname\n    if (currentPath.includes('/employer/') || currentPath.includes('/jobprovider/')) {\n      userRole.value = 'employer'\n    } else {\n      userRole.value = 'employee'\n    }\n  }\n  \n  // Debug logging\n  console.log('ðŸ” Role Detection Debug:', {\n    roleId: roleId,\n    userRole: userRole.value,\n    currentPath: window.location.pathname,\n    localStorage_roleId: localStorage.getItem('roleId')\n  })\n  \n  // Manual override for testing (you can call this in console)\n  window.forceRole = (role) => {\n    userRole.value = role\n    console.log('ðŸ”§ Manual role override:', role)\n  }\n  \n  // ðŸ†• Get API endpoint prefix based on role\n  const getApiPrefix = () => {\n    const currentPath = window.location.pathname;\n    const isAdmin = isAdminUser();\n    \n    console.log('ðŸ” API Prefix Debug:', { \n      currentPath, \n      userRole: userRole.value, \n      isAdmin,\n      adminRoleId: localStorage.getItem('adminRoleId'),\n      employeeRoleId: localStorage.getItem('employeeRoleId'),\n      employerRoleId: localStorage.getItem('employerRoleId')\n    });\n    \n    // Check if user is admin (will now check URL path first)\n    if (isAdmin) {\n      console.log('ðŸ” Admin user detected, using admin API')\n      return '/admin/chat'\n    }\n    \n    // Employee uses /chat, Employer uses /chat/employer\n    const prefix = userRole.value === 'employer' ? '/chat/employer' : '/chat'\n    console.log('ðŸ” Using prefix:', prefix, 'for role:', userRole.value)\n    return prefix\n  }\n\n  // Function to update role based on current URL\n  const updateRoleFromURL = () => {\n    const currentPath = window.location.pathname\n    const newRole = (currentPath.includes('/employer/') || currentPath.includes('/jobprovider/')) ? 'employer' : 'employee'\n    if (userRole.value !== newRole) {\n      userRole.value = newRole\n      console.log('ðŸ”„ Role updated from URL:', { newRole, currentPath })\n    }\n  }\n\n  // Load history from localStorage AND backend on mount\n  onMounted(async () => {\n    // Update role detection on mount\n    updateRoleFromURL()\n    \n    const savedHistory = localStorage.getItem('kozi-chat-history')\n    if (savedHistory) {\n      try {\n        const parsedHistory = JSON.parse(savedHistory)\n        // Ensure all history items have proper timestamps\n        history.value = parsedHistory.map(item => ({\n          ...item,\n          timestamp: item.timestamp || new Date(item.createdAt).getTime() || Date.now(),\n          createdAt: item.createdAt || new Date(item.timestamp) || new Date()\n        }))\n        console.log('Loaded localStorage chat history:', history.value)\n      } catch (e) {\n        console.warn('Failed to load localStorage chat history:', e)\n        history.value = []\n      }\n    } else {\n      console.log('No saved localStorage chat history found')\n      history.value = []\n    }\n    \n    await initializeUser()\n    \n    if (currentUser.value) {\n      await loadHistoryFromBackend()\n      \n      // ðŸ†• AUTO-RESTORE LAST ACTIVE SESSION\n      const lastActive = getLastActiveSession()\n      console.log('ðŸ” Last active session check:', lastActive)\n      \n      if (lastActive?.sessionId) {\n        // Find this session in history\n        const sessionInHistory = history.value.find(\n          h => h.sessionId === lastActive.sessionId\n        )\n        \n        console.log('ðŸ” Session in history check:', sessionInHistory)\n        console.log('ðŸ” Available history:', history.value)\n        \n        if (sessionInHistory) {\n          console.log('ðŸ”„ Restoring last active session:', sessionInHistory)\n          // Move the loadChatHistory call to after all functions are defined\n          setTimeout(async () => {\n            try {\n              await loadChatHistory(sessionInHistory)\n            } catch (error) {\n              console.error('âŒ Failed to restore session:', error)\n            }\n          }, 100)\n        } else {\n          console.log('âš ï¸ Last active session not found in history, clearing')\n          clearLastActiveSession()\n        }\n      } else {\n        console.log('â„¹ï¸ No last active session found')\n      }\n    }\n  })\n\n  watch(\n    history,\n    (newHistory) => {\n      if (newHistory.length > 0) {\n        localStorage.setItem('kozi-chat-history', JSON.stringify(newHistory))\n      }\n    },\n    { deep: true },\n  )\n\n\n  const initializeUser = async () => {\n    try {\n      loading.value = true\n      const user = await getUser()\n      currentUser.value = user\n      console.log('User initialized:', user)\n    } catch (e) {\n      console.error('Failed to initialize user:', e)\n      error.value = 'Failed to initialize. Please refresh the page.'\n      messages.value = [\n        {\n          sender: 'assistant',\n          text: 'Sorry, I had trouble connecting. Please refresh the page and try again.',\n        },\n      ]\n    } finally {\n      loading.value = false\n    }\n  }\n\n  const addBotMessage = (text) => {\n    messages.value.push({ sender: 'assistant', text: formatMessage(text) })\n  }\n\n  const addUserMessage = (text) => {\n    messages.value.push({ sender: 'user', text })\n  }\n\n  const generateChatTitle = (firstMessage) => {\n    if (!firstMessage) return 'New Chat'\n\n    let title = firstMessage.trim()\n    title = title.replace(\n      /^(how|what|when|where|why|can|could|would|should|tell me|help me)\\s+/i,\n      '',\n    )\n    title = title.charAt(0).toUpperCase() + title.slice(1)\n\n    if (title.length > 50) {\n      title = title.substring(0, 47) + '...'\n    }\n\n    return title || 'New Chat'\n  }\n\n  const saveCurrentChatToHistory = () => {\n    if (!currentSession.value || messages.value.length === 0) return\n\n    const firstUserMessage = messages.value.find((m) => m.sender === 'user')?.text\n    const finalTitle = firstUserMessage\n      ? generateChatTitle(firstUserMessage)\n      : currentChatTitle.value\n\n    const lastMessage = messages.value[messages.value.length - 1]\n    let cleanLastMessage = ''\n\n    if (lastMessage) {\n      if (lastMessage.sender === 'user') {\n        cleanLastMessage = lastMessage.text\n      } else {\n        cleanLastMessage = stripHtmlAndFormat(lastMessage.text)\n      }\n    }\n\n    // FIX: Use current timestamp for new entries\n    const currentTimestamp = Date.now()\n\n    const chatEntry = {\n      sessionId: currentSession.value,\n      title: finalTitle,\n      date: new Date().toLocaleDateString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n      }),\n      timestamp: currentTimestamp, // Use current timestamp\n      messageCount: messages.value.length,\n      lastMessage: cleanLastMessage.substring(0, 100),\n      createdAt: new Date(currentTimestamp) // Add createdAt field\n    }\n\n    // Remove existing entry and add new one at the beginning\n    const filtered = history.value.filter((item) => item.sessionId !== currentSession.value)\n    history.value = [chatEntry, ...filtered].slice(0, 50)\n    \n    console.log('Saved chat to history:', chatEntry)\n  }\n\n  const startNewChat = async () => {\n    if (!currentUser.value) {\n      console.warn('No user available for new chat â€” initializing a demo user')\n      try {\n        await initializeUser()\n      } catch (e) {\n        // fallthrough, initializeUser handles its own errors\n      }\n      if (!currentUser.value) return\n    }\n\n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory()\n    }\n\n    messages.value = []\n    currentSession.value = null\n    chatStarted.value = false\n    error.value = null\n    currentChatTitle.value = 'New Chat'\n    clearLastActiveSession() // ðŸ†• Clear tracking for new chat\n    loading.value = true\n\n    try {\n      const data = await startSession(currentUser.value.users_id, null, getApiPrefix())\n      console.log('Session started:', data)\n\n      if (data?.data?.session_id) {\n        currentSession.value = data.data.session_id\n        chatStarted.value = true\n        saveLastActiveSession(data.data.session_id) // ðŸ†• Track this session\n      } else {\n        throw new Error('Invalid session response')\n      }\n    } catch (e) {\n      console.error('Failed to start session:', e)\n      error.value = 'Failed to start chat session'\n      addBotMessage('Sorry, I had trouble starting our chat. Please try again.')\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // ðŸš€ UPDATED: Streaming message handler\n  const sendMessage = async (text) => {\n    if (!text.trim() || !currentUser.value || loading.value) {\n      return\n    }\n\n    console.log('Sending message:', text)\n\n    // Auto-start chat if needed\n    if (!chatStarted.value || !currentSession.value) {\n      console.log('Auto-starting chat session...')\n      try {\n        loading.value = true\n        const data = await startSession(currentUser.value.users_id, null, getApiPrefix())\n\n        if (data?.data?.session_id) {\n          currentSession.value = data.data.session_id\n          chatStarted.value = true\n          saveLastActiveSession(data.data.session_id) // ðŸ†• Track this session\n        } else {\n          throw new Error('Failed to start session')\n        }\n      } catch (e) {\n        console.error('Auto-start failed:', e)\n        addBotMessage('Sorry, I could not connect right now. Please try again in a moment.')\n        loading.value = false\n        return\n      } finally {\n        loading.value = false\n      }\n    }\n\n    // Add user message immediately\n    addUserMessage(text)\n\n    const userMessages = messages.value.filter(m => m.sender === 'user')\n    const isFirstUserMessage = userMessages.length === 1\n\n    if (isFirstUserMessage) {\n      const newTitle = generateChatTitle(text)\n      currentChatTitle.value = newTitle\n    }\n\n    // Create empty placeholder for streaming response (shows only bot icon + typing dots)\n    const botMessageIndex = messages.value.length\n    messages.value.push({ \n      sender: 'assistant', \n      text: '', // Start with empty content\n      streaming: true \n    })\n\n    loading.value = true\n    error.value = null\n    streamingMessage.value = ''\n\n    try {\n      // ðŸš€ Call streaming API\n      await streamChatMessage(\n        currentSession.value, \n        text, \n        isFirstUserMessage,\n        (chunk) => {\n          // Only process content chunks, ignore status\n          if (chunk) {\n            streamingMessage.value += chunk\n            messages.value[botMessageIndex].text = formatMessage(streamingMessage.value)\n            messages.value[botMessageIndex].streaming = true\n          }\n        },\n        (jobs) => {\n          // Handle job data if provided\n          if (jobs && Array.isArray(jobs)) {\n            messages.value[botMessageIndex].jobs = jobs\n          }\n        },\n        (candidates) => {\n          // Handle candidate data if provided\n          if (candidates && Array.isArray(candidates)) {\n            messages.value[botMessageIndex].candidates = candidates\n          }\n        },\n        (title) => {\n          // Title update callback\n          if (title) {\n            currentChatTitle.value = title\n            \n            // Update the current session title in history\n            const sessionIndex = history.value.findIndex(\n              h => h.sessionId === currentSession.value\n            );\n            if (sessionIndex !== -1) {\n              history.value[sessionIndex].title = title;\n              // Update localStorage\n              localStorage.setItem('kozi_chat_history', JSON.stringify(history.value));\n            }\n          }\n        },\n        getApiPrefix()\n      )\n\n      // Mark streaming as complete\n      messages.value[botMessageIndex].streaming = false\n\n    } catch (e) {\n      console.error('Failed to send message:', e)\n      error.value = 'Failed to send message'\n      // Replace the empty streaming bubble with a friendly error card\n      messages.value[botMessageIndex] = {\n        sender: 'assistant',\n        text: formatMessage(\n          '**We hit a hiccup.**\\n\\n- Please check your internet and try again.\\n- If this keeps happening, refresh the page.'\n        ),\n        streaming: false\n      }\n    } finally {\n      loading.value = false\n      streamingMessage.value = ''\n    }\n  }\n\n  const sendSuggestion = async (text) => {\n    await sendMessage(text)\n  }\n\n  const loadChatHistory = async (historyItem) => {\n    if (!historyItem.sessionId) return\n\n    console.log('Loading chat history for session:', historyItem.sessionId)\n    \n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory()\n    }\n\n    loading.value = true\n    try {\n      const data = await getChatHistory(historyItem.sessionId, getApiPrefix())\n      console.log('Full response from getChatHistory:', data)\n\n      let loadedMessages = []\n      \n      if (data?.data?.messages && Array.isArray(data.data.messages)) {\n        loadedMessages = data.data.messages\n      } else if (data?.messages && Array.isArray(data.messages)) {\n        loadedMessages = data.messages\n      } else if (Array.isArray(data)) {\n        loadedMessages = data\n      }\n\n      if (loadedMessages.length > 0) {\n        const msgs = loadedMessages.map((m) => ({\n          sender: m.type === 'user' ? 'user' : 'assistant',\n          text: m.type === 'user' ? m.content : formatMessage(m.content || m.message || ''),\n        }))\n        \n        console.log('Processed messages:', msgs)\n        messages.value = msgs\n        currentSession.value = historyItem.sessionId\n        currentChatTitle.value = historyItem.title\n        chatStarted.value = true\n        saveLastActiveSession(historyItem.sessionId) // ðŸ†• Track this session\n      } else {\n        currentSession.value = historyItem.sessionId\n        currentChatTitle.value = historyItem.title\n        chatStarted.value = true\n        saveLastActiveSession(historyItem.sessionId) // ðŸ†• Track this session\n        messages.value = []\n      }\n    } catch (e) {\n      console.error('Failed to load history:', e)\n      currentSession.value = historyItem.sessionId\n      currentChatTitle.value = historyItem.title\n      chatStarted.value = true\n      saveLastActiveSession(historyItem.sessionId) // ðŸ†• Track this session\n      messages.value = []\n    } finally {\n      loading.value = false\n    }\n  }\n\n  async function getUserChatSessions(users_id) {\n    const url = `${API_BASE}${getApiPrefix()}/sessions?users_id=${users_id}`\n    const res = await fetch(url, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n    })\n    \n    if (!res.ok) {\n      const errorText = await res.text()\n      console.error('getUserChatSessions error:', res.status, errorText)\n      throw new Error(`getUserChatSessions failed: ${res.status}`)\n    }\n    \n    return await res.json()\n  }\n\n  const loadHistoryFromBackend = async () => {\n    if (!currentUser.value) return\n    \n    try {\n      console.log('Loading chat history from backend for user:', currentUser.value.users_id)\n      const data = await getUserChatSessions(currentUser.value.users_id)\n      \n      if (data?.sessions && Array.isArray(data.sessions)) {\n        const backendHistory = data.sessions.map(session => {\n          const lastMessage = session.messages && session.messages.length > 0 \n            ? session.messages[session.messages.length - 1]\n            : null\n          \n          let cleanLastMessage = ''\n          if (lastMessage) {\n            cleanLastMessage = lastMessage.type === 'user' \n              ? lastMessage.content \n              : stripHtmlAndFormat(lastMessage.content)\n          }\n          \n          // FIX: Use proper timestamp from backend\n          const sessionTimestamp = session.timestamp || \n                                  new Date(session.created_at).getTime() || \n                                  new Date(session.createdAt).getTime() ||\n                                  Date.now()\n          \n          return {\n            sessionId: session.id,\n            title: session.title || 'New Chat',\n            date: new Date(sessionTimestamp).toLocaleDateString('en-US', {\n              month: 'short',\n              day: 'numeric',\n              hour: '2-digit',\n              minute: '2-digit',\n            }),\n            timestamp: sessionTimestamp, // Use the proper timestamp\n            messageCount: session.messages ? session.messages.length : 0,\n            lastMessage: cleanLastMessage.substring(0, 100),\n            // Add createdAt for consistency\n            createdAt: new Date(sessionTimestamp)\n          }\n        })\n        \n        // Sort backend history by timestamp descending (newest first)\n        backendHistory.sort((a, b) => b.timestamp - a.timestamp)\n        \n        history.value = backendHistory\n        console.log('Loaded backend chat history:', backendHistory)\n        localStorage.setItem('kozi-chat-history', JSON.stringify(backendHistory))\n      } else {\n        console.log('No chat sessions found in backend')\n      }\n    } catch (e) {\n      console.error('Failed to load chat history from backend:', e)\n    }\n  }\n\n  // Delete a chat session by ID (backend + local)\n  const deleteHistoryItem = async (sessionId) => {\n    if (!sessionId) return\n\n    try {\n      const url = `${API_BASE}${getApiPrefix()}/session/${sessionId}`\n      const res = await fetch(url, { method: \"DELETE\" })\n\n      if (!res.ok) {\n        const errorText = await res.text()\n        console.error(\"deleteChatSession error:\", res.status, errorText)\n        throw new Error(`deleteChatSession failed: ${res.status}`)\n      }\n\n      const result = await res.json()\n      console.log(\"Deleted chat session:\", result)\n\n      // âœ… Remove from local history (filter instead of recursion)\n      history.value = history.value.filter(\n        (item) => item.sessionId !== sessionId\n      )\n\n      // Reset current session if it was the one deleted\n      if (currentSession.value === sessionId) {\n        currentSession.value = null\n        messages.value = []\n        currentChatTitle.value = \"New Chat\"\n        chatStarted.value = false\n        clearLastActiveSession() // ðŸ†• Clear tracking\n      }\n\n      return result\n    } catch (err) {\n      console.error(\"Failed to delete chat session:\", err)\n      throw err\n    }\n  }\n\n  const clearAllHistory = async () => {\n    // âœ… Get users_id from currentUser\n    if (!currentUser.value || !currentUser.value.users_id) {\n      console.error(\"âŒ Cannot clear history: User not logged in\")\n      return\n    }\n\n    const users_id = currentUser.value.users_id\n\n    try {\n      // Clear local history\n      history.value = []\n      localStorage.removeItem(\"kozi-chat-history\")\n\n      // Call backend API to clear sessions\n      const res = await fetch(`${API_BASE}${getApiPrefix()}/sessions/all`, {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ users_id }),\n      })\n\n      if (!res.ok) {\n        const data = await res.json()\n        console.error(\"âŒ Failed to clear server history:\", data.error || data)\n        return\n      }\n\n      const data = await res.json()\n      console.log(`âœ… Cleared ${data.deletedCount} sessions from server`)\n\n      // âœ… Reset current session state\n      currentSession.value = null\n      messages.value = []\n      currentChatTitle.value = \"New Chat\"\n      chatStarted.value = false\n      clearLastActiveSession() // ðŸ†• Clear tracking\n\n    } catch (err) {\n      console.error(\"âŒ Error clearing history:\", err)\n    }\n  }\n\n  const toggleTheme = () => {\n    document.body.classList.toggle('dark')\n  }\n\n  const handleBeforeUnload = () => {\n    if (currentSession.value && messages.value.length > 0) {\n      saveCurrentChatToHistory()\n    }\n  }\n\n  // Debug function to check timestamp consistency\n  const debugHistoryTimestamps = () => {\n    console.log('=== HISTORY TIMESTAMP DEBUG ===')\n    history.value.forEach((item, index) => {\n      console.log(`[${index}] ${item.title}:`, {\n        timestamp: item.timestamp,\n        date: item.date,\n        createdAt: item.createdAt,\n        sessionId: item.sessionId\n      })\n    })\n  }\n\n  onMounted(() => {\n    window.addEventListener('beforeunload', handleBeforeUnload)\n  })\n\n  onUnmounted(() => {\n    window.removeEventListener('beforeunload', handleBeforeUnload)\n    handleBeforeUnload()\n  })\n\n  return {\n    // State\n    currentUser: computed(() => currentUser.value),\n    currentSession: computed(() => currentSession.value),\n    messages: computed(() => messages.value),\n    history: computed(() => history.value),\n    chatStarted: computed(() => chatStarted.value),\n    loading: computed(() => loading.value),\n    error: computed(() => error.value),\n    currentChatTitle: computed(() => currentChatTitle.value),\n\n    // Actions\n    startNewChat,\n    sendMessage,\n    sendSuggestion,\n    loadChatHistory,\n    deleteHistoryItem,\n    clearAllHistory,\n    toggleTheme,\n    debugHistoryTimestamps, // Export debug function\n  }\n}\n\n// Utility functions\nfunction stripHtmlAndFormat(text = '') {\n  if (!text) return ''\n  let cleaned = text.replace(/<[^>]*>/g, '')\n  cleaned = cleaned.replace(/\\*\\*(.+?)\\*\\*/g, '$1')\n  cleaned = cleaned.replace(/\\*(.+?)\\*/g, '$1')\n  cleaned = cleaned.replace(/#{1,6}\\s*(.+)/g, '$1')\n  cleaned = cleaned.replace(/^\\d+\\.\\s*/gm, '')\n  cleaned = cleaned.replace(/^[-â€¢]\\s*/gm, '')\n  cleaned = cleaned.replace(/\\s+/g, ' ').trim()\n  return cleaned\n}\n\nfunction formatMessage(message = '') {\n  if (!message) return ''\n  let formatted = String(message).trim()\n\n  // Remove any orphan/mismatched **\n  formatted = formatted.replace(/(^|\\s)\\*\\*([^*]+)(\\s|$)/g, '$1<strong>$2</strong>$3')\n  formatted = formatted.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n  formatted = formatted.replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n\n  // Strip markdown headings / blockquotes\n  formatted = formatted.replace(/^[#>]+\\s*/gm, '')\n\n  // Numbered list items â†’ custom styled divs\n  formatted = formatted.replace(\n    /^(\\d+)\\.\\s+([^:]+:\\s*.+)$/gm,\n    '<div class=\"numbered-item large-font\"><span class=\"number\">$1.</span><span class=\"full-text\"> $2</span></div>'\n  )\n\n  // Bullet list items\n  formatted = formatted.replace(/^\\s*[-â€¢]\\s+(.+)$/gm, '<div class=\"bullet-item large-font\">$1</div>')\n\n  // Section headers\n  formatted = formatted.replace(/^(.+):$/gm, '<div class=\"section-header large-font\">$1</div>')\n\n  // Paragraph spacing\n  formatted = formatted.replace(/([^\\n])\\n\\n([^\\n])/g, '$1</p><p class=\"large-font\">$2')\n  formatted = formatted.replace(/(?<!<\\/div>)\\n(?!<div)/g, '<br>')\n  formatted = formatted.replace(/^\\s*<br>\\s*<br>\\s*/, '')\n\n  // Wrap in <p> if not already formatted\n  if (!formatted.includes('<div') && !formatted.includes('<p>')) {\n    formatted = `<p class=\"large-font\">${formatted}</p>`\n  }\n\n  return formatted\n}\n\n\n// ===== API integration with STREAMING =====\nconst API_BASE = (import.meta?.env?.VITE_API_URL || process.env.VUE_APP_API_URL || 'http://localhost:5050/api').replace(/\\/+$/, '')\n\n// Admin detection logic\nfunction isAdminUser() {\n  // Check current URL path first - only detect admin when actually on admin dashboard\n  const currentPath = window.location.pathname;\n  const isOnAdminDashboard = currentPath.startsWith('/admin');\n  \n  if (!isOnAdminDashboard) {\n    return false; // If not on admin dashboard, definitely not admin\n  }\n  \n  // If on admin dashboard, verify admin credentials\n  const adminRoleId = localStorage.getItem('adminRoleId');\n  const userEmail = localStorage.getItem('userEmail') || '';\n  \n  return adminRoleId === '3' || userEmail === 'admin@kozi.rw' || userEmail.includes('admin');\n}\n\n// Generic fetch with timeout (prevents infinite spinner if backend is down)\nasync function fetchWithTimeout(resource, options = {}) {\n  const { timeout = 10000 } = options // 10s default\n  const controller = new AbortController()\n  const id = setTimeout(() => controller.abort(), timeout)\n\n  try {\n    const response = await fetch(resource, { ...options, signal: controller.signal })\n    return response\n  } finally {\n    clearTimeout(id)\n  }\n}\n\nasync function getUser(email = process.env.VUE_APP_EMPLOYEE_EMAIL || 'test@example.com') {\n  try {\n    const API_TOKEN = process.env.VUE_APP_KOZI_API_TOKEN || 'your_kozi_api_token_here';\n\n    // Check local cache first\n    const cached = localStorage.getItem(DEMO_USER_CACHE_KEY);\n    if (cached) {\n      try {\n        const user = JSON.parse(cached);\n        if (user && user.users_id && user.email === email) {\n          return user;\n        } else {\n          localStorage.removeItem(DEMO_USER_CACHE_KEY);\n        }\n      } catch (e) {\n        localStorage.removeItem(DEMO_USER_CACHE_KEY);\n      }\n    }\n\n    if (!API_TOKEN) {\n      console.warn('Missing VITE_KOZI_API_TOKEN. Using demo user profile instead.')\n      return persistUserToCache(createFallbackUser(email))\n    }\n\n    // Fetch user_id\n    const resId = await fetch(\n      `https://apis.kozi.rw/get_user_id_by_email/${encodeURIComponent(email)}`,\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${API_TOKEN}`,\n        },\n      }\n    );\n    if (!resId.ok) throw new Error(\"Failed to fetch user ID\");\n    const dataId = await resId.json();\n\n    // Fetch full profile to get real name\n    const resProfile = await fetch(\n      `https://apis.kozi.rw/provider/view_profile/${dataId.users_id}`,\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${API_TOKEN}`,\n        },\n      }\n    );\n    if (!resProfile.ok) throw new Error(\"Failed to fetch user profile\");\n    const profile = await resProfile.json();\n\n    // Build user object\n    const user = {\n      users_id: dataId.users_id,\n      email,\n      first_name: profile.first_name || \"Alice\",\n      last_name: profile.last_name || \"Admin\",\n      role: \"employee\",\n    };\n\n    return persistUserToCache(user);\n  } catch (e) {\n    console.error(\"getUser error:\", e);\n    return persistUserToCache(createFallbackUser(email));\n  }\n}\n\nasync function startSession(users_id, firstMessage, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}/new`\n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ users_id, firstMessage }), \n    timeout: 10000\n  })\n  if (!res.ok) {\n    const errorText = await res.text().catch(() => '')\n    console.error('startSession error:', res.status, errorText)\n    throw new Error(`Start session failed (${res.status}). ${errorText || ''}`)\n  }\n  return await res.json()\n}\n\n// ðŸš€ NEW: Streaming message function\nasync function streamChatMessage(sessionId, message, isFirstUserMessage, onChunk, onJobs, onCandidates, onTitle, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}`\n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ \n      sessionId, \n      message, \n      isFirstUserMessage\n    }),\n    timeout: 60000 // Increased timeout for job searches\n  })\n\n  if (!res.ok) {\n    const errorText = await res.text().catch(() => '')\n    console.error('streamChatMessage error:', res.status, errorText)\n    throw new Error(`Chat failed (${res.status}). ${errorText || ''}`)\n  }\n\n  // If backend responded with JSON (non-SSE fallback), handle gracefully\n  const contentType = res.headers.get('content-type') || ''\n  if (contentType.includes('application/json')) {\n    const json = await res.json()\n    if (json?.data?.content) {\n      onChunk(json.data.content, null)\n    } else if (json?.content) {\n      onChunk(json.content, null)\n    } else if (json?.messages) {\n      // Join messages content for display\n      const joined = (json.messages || [])\n        .map(m => (m.type === 'user' ? '' : m.content))\n        .filter(Boolean)\n        .join('\\n')\n      if (joined) onChunk(joined, null)\n    }\n    return\n  }\n\n  // Handle SSE streaming\n  if (!res.body || !res.body.getReader) {\n    // Some environments (older browsers/proxies) may buffer the whole body\n    const text = await res.text()\n    if (text) {\n      try {\n        const maybe = JSON.parse(text)\n        if (maybe?.content) onChunk(maybe.content, null)\n      } catch {\n        onChunk(text, null)\n      }\n    }\n    return\n  }\n  const reader = res.body.getReader()\n  const decoder = new TextDecoder('utf-8')\n  let buffer = ''\n  \n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) break\n    \n    buffer += decoder.decode(value, { stream: true })\n    const lines = buffer.split('\\n')\n    buffer = lines.pop() || ''\n    \n    for (const line of lines) {\n      const trimmed = line.trim()\n      if (!trimmed.startsWith('data:')) continue\n      \n      const payload = trimmed.slice(5).trim()\n      if (!payload || payload === '[DONE]') continue\n      \n      try {\n        const event = JSON.parse(payload)\n        if (event.content) {\n          // Content chunk - only process actual content\n          onChunk(event.content, null)\n        } else if (event.jobs) {\n          // Job data\n          onJobs(event.jobs)\n        } else if (event.candidates) {\n          // Candidate data\n          onCandidates(event.candidates)\n        } else if (event.title) {\n          // Title update\n          onTitle(event.title)\n        } else if (event.done) {\n          // Streaming complete\n          break\n        } else if (event.error) {\n          throw new Error(event.error)\n        }\n        // Ignore status events (processing, generating)\n      } catch (parseError) {\n        console.warn('Failed to parse SSE event:', parseError)\n      }\n    }\n  }\n}\n\nasync function getChatHistory(sessionId, rolePrefix = '/chat') {\n  const url = `${API_BASE}${rolePrefix}?action=loadPreviousSession`\n  console.log('Fetching chat history from:', url, 'with sessionId:', sessionId)\n  \n  const res = await fetchWithTimeout(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ sessionId }),\n    timeout: 10000\n  })\n  \n  if (!res.ok) {\n    const errorText = await res.text()\n    console.error('getChatHistory error:', res.status, errorText)\n    throw new Error(`getChatHistory failed: ${res.status}`)\n  }\n  \n  const responseData = await res.json()\n  console.log('Raw response from getChatHistory:', JSON.stringify(responseData, null, 2))\n  return responseData\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}